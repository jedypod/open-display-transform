#line 2 // Fix line numbers in resolve/logs/rollinglog.txt

/* OpenDRT v1.0.1 -------------------------------------------------


  Written by Jed Smith
  https://github.com/jedypod/open-display-transform
  License: GPLv3
  -------------------------------------------------*/



// Input settings
DEFINE_UI_PARAMS(in_gamut, Input Gamut, DCTLUI_COMBO_BOX, 15, {i_xyz, i_ap0, i_ap1, i_p3d65, i_rec2020, i_rec709, i_awg3, i_awg4, i_rwg, i_sgamut3, i_sgamut3cine, i_vgamut, i_bmdwg, i_egamut, i_egamut2, i_davinciwg}, {XYZ, ACES 2065-1, ACEScg, P3D65, Rec.2020, Rec.709, Arri Wide Gamut 3, Arri Wide Gamut 4, Red Wide Gamut RGB, Sony SGamut3, Sony SGamut3Cine, Panasonic V-Gamut, Blackmagic Wide Gamut, Filmlight E-Gamut, Filmlight E-Gamut2, DaVinci Wide Gamut})
DEFINE_UI_PARAMS(in_oetf, Input Transfer Function, DCTLUI_COMBO_BOX, 1, {ioetf_linear, ioetf_davinci_intermediate, ioetf_filmlight_tlog, ioetf_acescct, ioetf_arri_logc3, ioetf_arri_logc4, ioetf_redlog3g10, ioetf_panasonic_vlog, ioetf_sony_slog3, ioetf_fuji_flog}, {Linear, Davinci Intermediate, Filmlight T-Log, ACEScct, Arri LogC3, Arri LogC4, RedLog3G10, Panasonic V-Log, Sony S-Log3, Fuji F-Log2})

// Tonescale Parameters
DEFINE_UI_PARAMS(tn_Lp, Display Peak Luminance, DCTLUI_SLIDER_FLOAT, 100.0, 100.0, 1000.0, 0.0)
DEFINE_UI_PARAMS(tn_gb, HDR Grey Boost, DCTLUI_SLIDER_FLOAT, 0.13, 0.0, 1.0, 0.0)
DEFINE_UI_PARAMS(pt_hdr, HDR Purity, DCTLUI_SLIDER_FLOAT, 0.5, 0.0, 1.0, 0.0)

// Clamp
DEFINE_UI_PARAMS(_clamp, Clamp, DCTLUI_CHECK_BOX, 1)

DEFINE_UI_PARAMS(crv_enable, Tonescale Overlay, DCTLUI_CHECK_BOX, 0)





/*--------------------------------------------------------------------------------------
  Due to the limited nature of DCTL, I've made the choice to only expose the presets
  and not the full parameter space. For those of you who are too curious for your own good
  and interested in experimenting...

!!! TO ENABLE STICKSHIFT MODE FOR CUSTOM LOOK CREATION:
    1. **UN-COMMENT** the lines below, including the define INIT_PARAMS line. This enables all of the user parameters.
    2. Comment out the lines below that for the preset parameters (You can leave them enabled, but they won't do anything)

  Tip 1: If you are using a modern text editor like VSCode,
    you can comment or un-comment multiple selected lines with Ctrl+/
  Tip 2: You can use the Nuke node to create a preset and click the "Show DCTL" button
    to show code for the below with your custom parameter values. Or add your own presets
    in the LOOK PRESETS section around line 464.
---------------------------------------------------------------------------------------*/


// #define INIT_PARAMS

// DEFINE_UI_PARAMS(_tn_Lg, Grey Luminance, DCTLUI_SLIDER_FLOAT, 11.1, 4.0, 25.0, 0.0)
// DEFINE_UI_PARAMS(_tn_con, Contrast, DCTLUI_SLIDER_FLOAT, 1.4, 1.0, 2.0, 0.0)
// DEFINE_UI_PARAMS(_tn_sh, Shoulder Clip, DCTLUI_SLIDER_FLOAT, 0.5, 0.0, 1.0, 0.0)
// DEFINE_UI_PARAMS(_tn_toe, Toe, DCTLUI_SLIDER_FLOAT, 0.003, 0.0, 0.1, 0.0)
// DEFINE_UI_PARAMS(_tn_off, Offset, DCTLUI_SLIDER_FLOAT, 0.005, 0.0, 0.02, 0.0)
// DEFINE_UI_PARAMS(_tn_hcon_enable, Enable Contrast High, DCTLUI_CHECK_BOX, 1)
// DEFINE_UI_PARAMS(_tn_hcon, Contrast High, DCTLUI_SLIDER_FLOAT, 0.0, -1.0, 1.0, 0.0)
// DEFINE_UI_PARAMS(_tn_hcon_pv, Contrast High Pivot, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 4.0, 0.0)
// DEFINE_UI_PARAMS(_tn_hcon_st, Contrast High Strength, DCTLUI_SLIDER_FLOAT, 4.0, 0.0, 4.0, 0.0)
// DEFINE_UI_PARAMS(_tn_lcon_enable, Enable Contrast Low, DCTLUI_CHECK_BOX, 1)
// DEFINE_UI_PARAMS(_tn_lcon, Contrast Low, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 3.0, 0.0)
// DEFINE_UI_PARAMS(_tn_lcon_w, Contrast Low Width, DCTLUI_SLIDER_FLOAT, 0.5, 0.0, 2.0, 0.0)
// DEFINE_UI_PARAMS(_tn_lcon_pc, Contrast Low Per-Channel, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 1.0, 0.0)
// DEFINE_UI_PARAMS(_cwp, Creative White, DCTLUI_COMBO_BOX, 0, {_cwp0, _cwp1, _cwp2, _cwp3}, {D65, D60, D55, D50})
// DEFINE_UI_PARAMS(_cwp_rng, Creative White Range, DCTLUI_SLIDER_FLOAT, 0.5, 0.0, 1.0, 0.0)
// DEFINE_UI_PARAMS(_rs_sa, Render Space Strength, DCTLUI_SLIDER_FLOAT, 0.35, 0.0, 0.6, 0.0)
// DEFINE_UI_PARAMS(_rs_rw, Render Space Red Weight, DCTLUI_SLIDER_FLOAT, 0.25, 0.0, 0.8, 0.0)
// DEFINE_UI_PARAMS(_rs_bw, Render Space Blue Weight, DCTLUI_SLIDER_FLOAT, 0.55, 0.0, 0.8, 0.0)
// DEFINE_UI_PARAMS(_pt_r, Purity Compress R, DCTLUI_SLIDER_FLOAT, 0.5, 0.0, 4.0, 0.0)
// DEFINE_UI_PARAMS(_pt_g, Purity Compress G, DCTLUI_SLIDER_FLOAT, 2.0, 0.0, 4.0, 0.0)
// DEFINE_UI_PARAMS(_pt_b, Purity Compress B, DCTLUI_SLIDER_FLOAT, 2.0, 0.0, 4.0, 0.0)
// DEFINE_UI_PARAMS(_pt_rng_low, Purity Range Low, DCTLUI_SLIDER_FLOAT, 0.2, 0.1, 0.6, 0.0)
// DEFINE_UI_PARAMS(_pt_rng_high, Purity Range High, DCTLUI_SLIDER_FLOAT, 0.8, 0.25, 2.0, 0.0)
// DEFINE_UI_PARAMS(_ptl_enable, Enable Purity Compress Low , DCTLUI_CHECK_BOX, 1)
// DEFINE_UI_PARAMS(_ptm_enable, Enable Mid Purity, DCTLUI_CHECK_BOX, 1)
// DEFINE_UI_PARAMS(_ptm_low, Mid Purity Low, DCTLUI_SLIDER_FLOAT, 0.2, 0.0, 1.0, 0.0)
// DEFINE_UI_PARAMS(_ptm_low_st, Mid Purity Low Strength, DCTLUI_SLIDER_FLOAT, 0.5, 0.1, 1.0, 0.0)
// DEFINE_UI_PARAMS(_ptm_high, Mid Purity High, DCTLUI_SLIDER_FLOAT, -0.8, -0.9, 0.0, 0.0)
// DEFINE_UI_PARAMS(_ptm_high_st, Mid Purity High Strength, DCTLUI_SLIDER_FLOAT, 0.3, 0.2, 1.0, 0.0)
// DEFINE_UI_PARAMS(_brl_enable, Enable Brilliance, DCTLUI_CHECK_BOX, 1)
// DEFINE_UI_PARAMS(_brl_r, Brilliance R, DCTLUI_SLIDER_FLOAT, -0.5, -1.0, 1.0, 0.0)
// DEFINE_UI_PARAMS(_brl_g, Brilliance G, DCTLUI_SLIDER_FLOAT, -0.4, -1.0, 1.0, 0.0)
// DEFINE_UI_PARAMS(_brl_b, Brilliance B, DCTLUI_SLIDER_FLOAT, -0.2, -1.0, 1.0, 0.0)
// DEFINE_UI_PARAMS(_brl_c, Brilliance C, DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.0)
// DEFINE_UI_PARAMS(_brl_m, Brilliance M, DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.0)
// DEFINE_UI_PARAMS(_brl_y, Brilliance Y, DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.0)
// DEFINE_UI_PARAMS(_brl_rng, Brilliance Range, DCTLUI_SLIDER_FLOAT, 0.66, 0.0, 1.0, 0.0)
// DEFINE_UI_PARAMS(_hs_rgb_enable, Enable Hueshift RGB, DCTLUI_CHECK_BOX, 1)
// DEFINE_UI_PARAMS(_hs_r, Hueshift R, DCTLUI_SLIDER_FLOAT, 0.35, 0.0, 1.0, 0.0)
// DEFINE_UI_PARAMS(_hs_g, Hueshift G, DCTLUI_SLIDER_FLOAT, 0.25, 0.0, 1.0, 0.0)
// DEFINE_UI_PARAMS(_hs_b, Hueshift B, DCTLUI_SLIDER_FLOAT, 0.5, 0.0, 1.0, 0.0)
// DEFINE_UI_PARAMS(_hs_rgb_rng, Hueshift RGB Range, DCTLUI_SLIDER_FLOAT, 0.6, 0.25, 1.0, 0.0)
// DEFINE_UI_PARAMS(_hs_cmy_enable, Enable Hueshift CMY, DCTLUI_CHECK_BOX, 1)
// DEFINE_UI_PARAMS(_hs_c, Hueshift C, DCTLUI_SLIDER_FLOAT, 0.2, 0.0, 1.0, 0.0)
// DEFINE_UI_PARAMS(_hs_m, Hueshift M, DCTLUI_SLIDER_FLOAT, 0.2, 0.0, 1.0, 0.0)
// DEFINE_UI_PARAMS(_hs_y, Hueshift Y, DCTLUI_SLIDER_FLOAT, 0.2, 0.0, 1.0, 0.0)
// DEFINE_UI_PARAMS(_hc_enable, Enable Hue Contrast, DCTLUI_CHECK_BOX, 1)
// DEFINE_UI_PARAMS(_hc_r, Hue Contrast R, DCTLUI_SLIDER_FLOAT, 0.6, 0.0, 1.0, 0.0)


// DEFINE_UI_PARAMS(_display_gamut, Display Gamut, DCTLUI_COMBO_BOX, 0, {Rec709, P3D65, Rec2020}, {Rec.709, P3-D65, Rec.2020 (P3 Limited)})
// DEFINE_UI_PARAMS(_eotf, Display EOTF, DCTLUI_COMBO_BOX, 2, {eotf0, eotf1, eotf2, eotf3, eotf4, eotf5}, {Linear, 2.2 Power sRGB Display, 2.4 Power Rec.1886, 2.6 Power DCI, ST 2084 PQ, HLG})


/*---------------------------------------------------------------------------------------
!!! TO ENABLE STICKSHIFT MODE FOR CUSTOM LOOK CREATION: **COMMENT OUT** the preset parameters below.
---------------------------------------------------------------------------------------*/

// Preset Parameters
DEFINE_UI_PARAMS(look_preset, Look Preset, DCTLUI_COMBO_BOX, 0, {look0, look1, look2, look3}, {Default, Colorful, Umbra, Base})
DEFINE_UI_PARAMS(tonescale_preset, Tonescale Preset, DCTLUI_COMBO_BOX, 0, {tsprst0, tsprst1, tsprst2, tsprst3, tsprst4, tsprst5, tsprst6, tsprst7, tsprst8, tsprst9}, {Use Look Preset, High-Contrast, Low-Contrast, ACES-1.x, ACES-2.0, Marvelous Tonescape, Arriba Tonecall, DaGrinchi Tonegroan, Aery Tonescale, Umbra Tonescale})
// Creative White
DEFINE_UI_PARAMS(_cwp, Creative White, DCTLUI_COMBO_BOX, 4, {_cwp0, _cwp1, _cwp2, _cwp3, _cwp4}, {D65, D60, D55, D50, Use Look Preset})
DEFINE_UI_PARAMS(_cwp_rng, Creative White Range, DCTLUI_SLIDER_FLOAT, 0.5, 0.0, 1.0, 0.0)
// Display Encoding
DEFINE_UI_PARAMS(display_encoding_preset, Display Encoding Preset, DCTLUI_COMBO_BOX, 0, {rec1886, srgb, displayp3, rec2100pq, rec2100hlg, dolbypq}, {Rec.1886 - 2.4 Power / Rec.709, sRGB Display - 2.2 Power / Rec.709, Display P3 - 2.2 Power / P3-D65, Rec.2100 - PQ / Rec.2020 (P3 Limited), Rec.2100 - HLG / Rec.2020 (P3 Limited), Dolby - PQ / P3-D65})

/*---------------------------------------------------------------------------------------*/




/*----------- Tooltips -----------------*/
#if ((__RESOLVE_VER_MAJOR__ > 19)) || ((__RESOLVE_VER_MAJOR__ == 19) && (__RESOLVE_VER_MINOR__ >= 1))

DEFINE_UI_TOOLTIP(Display Peak Luminance, "Peak display luminance in nits. In SDR, the max value stays pinned at 1.0. In HDR, the max value is adjusted to match peak luminance in the HDR container.")
DEFINE_UI_TOOLTIP(HDR Grey Boost, "Amount of stops to boost Grey Luminance, per stop of exposure increase of Peak Luminance. For example, if HDR Grey Boost is 0.1, middle grey will be boosted by 0.1 stops per stop of Peak Luminance increase.")
DEFINE_UI_TOOLTIP(HDR Purity, "How much to affect purity compression as Peak Luminance increases. A value of 0.0 will keep the purity compression behavior exactly the same for SDR and HDR. A value of 1.0 will preserve more purity as peak luminance increases (at the risk of gradient disruptions in high purity high intensity light sources).")
DEFINE_UI_TOOLTIP(Creative White, "Set the creative whitepoint of the display peak luminance. With D65 all channels are equal. With D50, the peak luminance value will match a D50 whitepoint. This can be creatively desireable. This adjustment is applied post-tonescale.")
DEFINE_UI_TOOLTIP(Creative White Range, "The intensity range affected by the Creative White adjustment. At 1.0, the entire intensity range is affected. As Range is decreased, more of midtones and shadows are left unaffected. It can be creatively desireable to keep midtones more neutral while shifting highlights warmer.")
DEFINE_UI_TOOLTIP(Clamp, "Clamp the final image into the final range supported by the display device.")
DEFINE_UI_TOOLTIP(Tonescale Overlay, "Draws a visualization of the tonescale curve. A semi-log plot over ~ -0.005 to 128, with display encoding added.")
DEFINE_UI_TOOLTIP(Look Preset, "Choose a preset look. DEFAULT is an image formation that includes minimal adjustments for an aesthetically pleasing image. COLORFUL: A very saturated bright exhuberant look, a good fit for animation. UMBRA: A dark moody cinematic look with very low shadow contrast, strong color crosstalk, natural blues, and a warm D50 whitepoint. BASE: only the base components of the OpenDRT image rendering. Practically no preferential adjustements. Purity compression is chromaticity-linear and very minimal. Bright saturated highlights will clip. Mid-range purity is very strong. A good starting point for further look development if absolute control is desired._________________________________________________")
DEFINE_UI_TOOLTIP(Tonescale Preset, "Presets specifically for the tonescale function. A number of creative options show the possibilities.  DEFAULT HIGH-CONTRAST:The default tonescale curve. Enough contrast to maybe be called a finished image, but also could be a good base to build on. LOW-CONTRAST: A low contrast tonescale curve that is intended as a starting point for further grading. Requires further contrast to be added in order to achieve something resembling a finished image (unless of course a very low contrast look is desired). ACES 1.x: A rough match of the ACES 1.x tonescale curve. One deviation is mapping 0.0 to 0.0 through the tonescale curve, rather than mapping +0.02 to 0.0... because that is moronic. ACES 2.0: An exact match to the ACES 2.0 tonescale function. Very low contrast in the highlights, and very strong shadow toe compression while mapping 0 to 0 through the tonescale function. Be careful with this one if adding additional shadow contrast upstream, without a strong positive offset. MARVELOUS TONESCAPE: A dark contrasty cinematic tonescale, which maps middle grey to 6 nits in SDR instead of the more typical camera DRT method of 11.1 nits following the Rec.709 OETF standard. Another way to think about this is that this tonescale is designed for a brighter SDR display. ARRIBA TONECALL: A low-contrast tonescale with an approach to shadows more typical of camera style DRTs, where there is a strong positive offset, and strong shadow toe compression. DAGRINCHI TONEGROAN: Another low-contrast tonescale designed as a starting point for further manipulations. Not as good as other options. AERY TONESCALE: An aery tonescale function. UMBRA TONESCALE: The tonescale from the Umbra look preset.")
DEFINE_UI_TOOLTIP(Display Encoding Preset, "Choose the target display standard.")

DEFINE_UI_TOOLTIP(Grey Luminance, "Display luminance for middle grey (0.18) in nits. Sets the target value for middle grey within the available luminance range of the display device.")
DEFINE_UI_TOOLTIP(Contrast, "Adjusts contrast or slope. A constrained power function applied in display linear.")
DEFINE_UI_TOOLTIP(Shoulder Clip, "Unitless control for the scene-linear value at which the tonescale system crosses the peak display linear value (1.0) and clips. This is not an exact constraint in order to keep the system simple, but corresponds to roughly 16 at Shoulder Clip = 0 and 1024 at Shoulder Clip = 1")
DEFINE_UI_TOOLTIP(Toe, "Quadratic toe compression. Strongly compresses deep shadows. Helpful to have some amount to smooth the transition into display minimum. Higher values with a strong positive Offset also valid. Similar to common camera DRT tonescale strategies.")
DEFINE_UI_TOOLTIP(Offset, "Pre-tonescale scene-linear offset. If 0.0, scene-linear 0.0 maps to display-linear 0.0 through the tonescale system. Many camera imaging pipelines apply a negative offset to set the average of shadow grain at 0.0. A positive Offset can be desireable to compensate for this and increase detail in shadows, in addition to being aesthetically desireable. Offset should NOT be a negative number (Looking at you ACES 1.x)")
DEFINE_UI_TOOLTIP(Enable Contrast High, "Contrast High allows control of the upper section of the tonescale function. Off by default, but can be useful if a stronger highlight contrast, or a softer highlight rolloff behavior is desired.")
DEFINE_UI_TOOLTIP(Contrast High, "Amount adjust highlights. Positive values increase highlight exposure, negative values decrease. 0 has no effect.")
DEFINE_UI_TOOLTIP(Contrast High Pivot, "Amount of stops above middle grey (0.18) to start the adjustment.")
DEFINE_UI_TOOLTIP(Contrast High Strength, "How quickly above the Contrast High Pivot the effect begins.")
DEFINE_UI_TOOLTIP(Enable Contrast Low, "Contrast Low adds contrast to the midtones and shadows. Middle grey (0.18) is un-changed through the adjustment.")
DEFINE_UI_TOOLTIP(Contrast Low, "Amount of contrast to add. 0.0 has no effect. 1.0 will expose down by 1 stop at the origin (0,0)")
DEFINE_UI_TOOLTIP(Contrast Low Width, "The width of the adjustment. Width below 0.5 will mostly affect values between 0 and middle grey. Values above 0.5 will increasingly start to increase highlight contrast, which could be desired or not depending on what you are trying to do.")
DEFINE_UI_TOOLTIP(Contrast Low Per-Channel, "How much to apply Contrast Low using a per-channel method, which can introduce pleasing mid-range purity boosts and hue distortions. A value of 0.0 will preserve purity and hue angle. A value of 1.0 will use a per-channel method in low and mid purities. At high purities, purity is always preserved to avoid artifacts.")
DEFINE_UI_TOOLTIP(Creative White, "Set the creative whitepoint of the display peak luminance. With D65 all channels are equal. With D50, the peak luminance value will match a D50 whitepoint. This can be creatively desireable. This adjustment is applied post-tonescale.")
DEFINE_UI_TOOLTIP(Creative White Range, "The intensity range affected by the Creative White adjustment. At 1.0, the entire intensity range is affected. As Range is decreased, more of midtones and shadows are left unaffected. It can be creatively desireable to keep midtones more neutral while shifting highlights warmer.")
DEFINE_UI_TOOLTIP(Render Space Strength, "Render space is the encoding in which the RGB Ratios are taken. Strength controls how much to desaturate from P3 gamut. Creatively, the more you desaturate, the more brilliance is increased in the resulting image. To be used with caution as this affects every other aspect of the image rendering.")
DEFINE_UI_TOOLTIP(Render Space Red Weight, "The Red weight of the Render Space Strength. Modify with caution as this affects every other part of the image rendering.")
DEFINE_UI_TOOLTIP(Render Space Blue Weight, "The Blue weight of the Render Space Strength. Modify with caution as this affects every other part of the image rendering.")
DEFINE_UI_TOOLTIP(Purity Compress R, "Adjust the amount of purity compression as intensity increases for Reds, Oranges and Magentas. A value of 0.0 will result in no purity compression and discontinuities in gradients in high purity high intensity light sources. A higher value will compress purity more as intensity increases.")
DEFINE_UI_TOOLTIP(Purity Compress G, "Adjust the amount of purity compression as intensity increases for Greens, Yellows and Cyans. A value of 0.0 will result in no purity compression and discontinuities in gradients in high purity high intensity light sources. A higher value will compress purity more as intensity increases.")
DEFINE_UI_TOOLTIP(Purity Compress B, "Adjust the amount of purity compression as intensity increases for Blue. A value of 0.0 will result in no purity compression and discontinuities in gradients in high purity high intensity light sources. A higher value will compress purity more as intensity increases.")
DEFINE_UI_TOOLTIP(Purity Range Low, "Where over the intensity range the purity compression starts. Higher values will compress purity more for low intensity. For example a Purity Range Low value of 0.5 will result in desaturated looking midtones.")
DEFINE_UI_TOOLTIP(Purity Range High, "Where over the intensity range the purity compression ends. Lower values will limit how much purity will be compressed at high intensities. For example a Purity Range High value of 0.5 will result in highly saturated looking highlights, at the risk of gradient discontinuities.")
DEFINE_UI_TOOLTIP(Enable Purity Compress Low , "Purity Compress Low increases tonality and smoothness in extremely pure input values that can not be adequately compressed into the display-referred gamut volume. The algorithm is tuned for common camera observer colorimetry sources. To keep the interface simple, this algorithm is exposed only as a boolean checkbox.")
DEFINE_UI_TOOLTIP(Enable Mid Purity, "The Mid Purity module adjusts mid-range purity of midtones and highlights. Without this module enabled, it is likely that midtones will not appear colorful enough, and highlights will appear too colorful resulting in chaulky pasty looking images especially in yellows and cyans. ")
DEFINE_UI_TOOLTIP(Mid Purity Low, "Amount to increase purity of midtones and shadows in mid-range purity areas. A value of 0.0 will have no effect. A value of 1.0 is the maximum possible value while preserving smoothness.")
DEFINE_UI_TOOLTIP(Mid Purity Low Strength, "The strength of the Mid Purity Low adjustment. Higher values affect more of the purity range.")
DEFINE_UI_TOOLTIP(Mid Purity High, "Amount to decrease purity of upper midtones and highlights in mid-range purity areas. A value of 0.0 will have no effect. A value of 1.0 is the maximum possible value while preserving smoothness.")
DEFINE_UI_TOOLTIP(Mid Purity High Strength, "The strength of the Mid Purity High adjustment. Higher values affect more of the purity range.")
DEFINE_UI_TOOLTIP(Enable Brilliance, "Brilliance scales the intensity of more pure stimuli. With the OpenDRT algorithm it is possible to get high intensity high purity values going out of the top of the display-referred gamut volume, which can cause discontinuities in gradients. The Brilliance module exists compensate for this, and to add some darkening to more pure stimuli, which can be creatively desireable.")
DEFINE_UI_TOOLTIP(Brilliance R, "Scale intensity of high-purity reds.")
DEFINE_UI_TOOLTIP(Brilliance G, "Scale intensity of high-purity greens.")
DEFINE_UI_TOOLTIP(Brilliance B, "Scale intensity of high-purity blues.")
DEFINE_UI_TOOLTIP(Brilliance C, "Scale intensity of high-purity cyans.")
DEFINE_UI_TOOLTIP(Brilliance M, "Scale intensity of high-purity megantas.")
DEFINE_UI_TOOLTIP(Brilliance Y, "Scale intensity of high-purity yellows.")
DEFINE_UI_TOOLTIP(Brilliance Range, "As Brilliance Range is increased, the brilliance adjustments affect more the low intensity values of the image data.")
DEFINE_UI_TOOLTIP(Enable Hueshift RGB, "Hue Shift RGB adds hue distortion to the red green and blue primary hue angles as intensity increases. By default OpenDRT will compress purity in a straight line in RGB/Chromaticity space. This can lead to perceived hue shifts due to the Abney Effect, for example a pure blue will perceptually shift towards purple as it desaturates. To compensate for this, and to use as a creative tool, this module allows creative control over the path that red green and blue hue angles take as their purity is compressed.")
DEFINE_UI_TOOLTIP(Hueshift R, "Amount to distort the red hue angle towards yellow as intensity increases.")
DEFINE_UI_TOOLTIP(Hueshift G, "Amount to distort the green hue angle towards yellow as intensity increases.")
DEFINE_UI_TOOLTIP(Hueshift B, "Amount to distort the blue hue angle towards cyan as intensity increases.")
DEFINE_UI_TOOLTIP(Hueshift RGB Range, "Amount of intensity range to affect with HueShift RGB.")
DEFINE_UI_TOOLTIP(Enable Hueshift CMY, "Hue Shift CMY adds hue distortion to the cyan magenta and yellow secondary hue angles as intensity decreases. This module allows some very minimal adjustments of secondary hue angles as a creative tool.")
DEFINE_UI_TOOLTIP(Hueshift C, "Amount to distort the cyan hue angle towards blue as intensity decreases.")
DEFINE_UI_TOOLTIP(Hueshift M, "Amount to distort the magenta hue angle towards blue as intensity decreases.")
DEFINE_UI_TOOLTIP(Hueshift Y, "Amount to distort the yellow hue angle towards red as intensity decreases.")
DEFINE_UI_TOOLTIP(Enable Hue Contrast, "Hue Contrast compresses hue angle towards the primary at the bottom end and expands the hue angle towards the secondary as intensity increases. It also increases purity as it compresses, and decreases purity as it expands. This leads to a nice creatively controllable simulation of this effect from per-channel tonescales. For OpenDRT we only keep the red hue angle control since it is the most useful.")
DEFINE_UI_TOOLTIP(Hue Contrast R, "Amount to increase Hue Contrast at the red hue angle.")

#endif



// Gamut Conversion Matrices
#define matrix_ap0_to_xyz make_float3x3(make_float3(0.93863094875f, -0.00574192055f, 0.017566898852f), make_float3(0.338093594922f, 0.727213902811f, -0.065307497733f), make_float3(0.000723121511f, 0.000818441849f, 1.0875161874f))
#define matrix_ap1_to_xyz make_float3x3(make_float3(0.652418717672f, 0.127179925538f, 0.170857283842f), make_float3(0.268064059194f, 0.672464478993f, 0.059471461813f), make_float3(-0.00546992851f, 0.005182799977f, 1.08934487929f))
#define matrix_rec709_to_xyz make_float3x3(make_float3(0.412390917540f, 0.357584357262f, 0.180480793118f), make_float3(0.212639078498f, 0.715168714523f, 0.072192311287f), make_float3(0.019330825657f, 0.119194783270f, 0.950532138348f))
#define matrix_p3d65_to_xyz make_float3x3(make_float3(0.486571133137f, 0.265667706728f, 0.198217317462f), make_float3(0.228974640369f, 0.691738605499f, 0.079286918044f), make_float3(0.0f, 0.045113388449, 1.043944478035f))
#define matrix_xyz_to_p3d65 make_float3x3(make_float3(2.49349691194f, -0.931383617919f, -0.402710784451f), make_float3(-0.829488969562f, 1.76266406032f, 0.023624685842f), make_float3(0.035845830244f, -0.076172389268f, 0.956884524008f))
#define matrix_rec2020_to_xyz make_float3x3(make_float3(0.636958122253f, 0.144616916776f, 0.168880969286f), make_float3(0.262700229883f, 0.677998125553f, 0.059301715344f), make_float3(0.0f, 0.028072696179, 1.060985088348f))
#define matrix_arriwg3_to_xyz make_float3x3(make_float3(0.638007619284f, 0.214703856337f, 0.097744451431f), make_float3(0.291953779f, 0.823841041511f, -0.11579482051f), make_float3(0.002798279032f, -0.067034235689f, 1.15329370742f))
#define matrix_arriwg4_to_xyz make_float3x3(make_float3(0.704858320407f, 0.12976029517f, 0.115837311474f), make_float3(0.254524176404f, 0.781477732712f, -0.036001909116f), make_float3(0.0f, 0.0f, 1.08905775076f))
#define matrix_redwg_to_xyz make_float3x3(make_float3(0.735275208950f, 0.068609409034f, 0.146571278572f), make_float3(0.286694079638f, 0.842979073524f, -0.129673242569f), make_float3(-0.079680845141f, -0.347343206406, 1.516081929207f))
#define matrix_sonysgamut3_to_xyz make_float3x3(make_float3(0.706482713192f, 0.128801049791f, 0.115172164069f), make_float3(0.270979670813f, 0.786606411221f, -0.057586082034f), make_float3(-0.009677845386f, 0.004600037493f, 1.09413555865f))
#define matrix_sonysgamut3cine_to_xyz make_float3x3(make_float3(0.599083920758f, 0.248925516115f, 0.102446490178f), make_float3(0.215075820116f, 0.885068501744f, -0.100144321859f), make_float3(-0.032065849545f, -0.027658390679f, 1.14878199098f))
#define matrix_vgamut_to_xyz make_float3x3(make_float3(0.679644469878f, 0.15221141244f, 0.118600044733), make_float3(0.26068555009f, 0.77489446333f, -0.03558001342), make_float3(-0.009310198218f, -0.004612467044f, 1.10298041602))
#define matrix_bmdwg_to_xyz make_float3x3(make_float3(0.606538414955f, 0.220412746072f, 0.123504832387f), make_float3(0.267992943525f, 0.832748472691f, -0.100741356611f), make_float3(-0.029442556202f, -0.086612440646, 1.205112814903f))
#define matrix_egamut_to_xyz make_float3x3(make_float3(0.705396831036f, 0.164041340351f, 0.081017754972f), make_float3(0.280130714178f, 0.820206701756f, -0.100337378681f), make_float3(-0.103781513870f, -0.072907261550, 1.265746593475f))
#define matrix_egamut2_to_xyz make_float3x3(make_float3(0.736477700184f, 0.130739651087f, 0.083238575781f), make_float3(0.275069984406f, 0.828017790216f, -0.103087774621f), make_float3(-0.124225154248f, -0.087159767391f, 1.3004426724f))
#define matrix_davinciwg_to_xyz make_float3x3(make_float3(0.700622320175f, 0.148774802685f, 0.101058728993f), make_float3(0.274118483067f, 0.873631775379f, -0.147750422359f), make_float3(-0.098962903023f, -0.137895315886, 1.325916051865f))

// Display gamuts with Normalized adaptation matrices for other creative whitepoints (CAT02)
#define matrix_p3_to_p3_d50 make_float3x3(make_float3(0.9287127388f, 0.06578032793f, 0.005506708345f), make_float3(-0.002887159176f, 0.8640709228f, 4.3593718e-05f), make_float3(-0.001009551548f, -0.01073503317f, 0.6672692039f))
#define matrix_p3_to_p3_d55 make_float3x3(make_float3(0.9559790976f, 0.0403850003f, 0.003639287409f), make_float3(-0.001771929896f, 0.9163058305f, 3.3300759e-05f), make_float3(-0.000674760809f, -0.0072466358f, 0.7831189153f))
#define matrix_p3_to_p3_d60 make_float3x3(make_float3(0.979832881f, 0.01836378979f, 0.001803284786f), make_float3(-0.000805359793f, 0.9618000331f, 1.8876121e-05f), make_float3(-0.000338382322f, -0.003671835795f, 0.894139105f))
#define matrix_p3_to_rec709_d50 make_float3x3(make_float3(1.103807322f, -0.1103425121f, 0.006531676079f), make_float3(-0.04079386701f, 0.8704694227f, -0.000180522628f), make_float3(-0.01854055914f, -0.07857582481f, 0.7105498861f))
#define matrix_p3_to_rec709_d55 make_float3x3(make_float3(1.149327514f, -0.1536910745f, 0.004366526746f), make_float3(-0.0412590771f, 0.9351717477f, -0.000116126221f), make_float3(-0.01900949528f, -0.07928282823f, 0.8437884317f))
#define matrix_p3_to_rec709_d60 make_float3x3(make_float3(1.189986856f, -0.192168414f, 0.002185496045f), make_float3(-0.04168263635f, 0.9927757018f, -5.5660878e-05f), make_float3(-0.01937995127f, -0.07933006919f, 0.9734397041f))
#define matrix_p3_to_rec709_d65 make_float3x3(make_float3(1.224940181f, -0.2249402404f, 0.0f), make_float3(-0.04205697775f, 1.042057037f, -1.4901e-08f), make_float3(-0.01963755488f, -0.07863604277f, 1.098273635f))
#define matrix_p3_to_rec2020 make_float3x3(make_float3(0.7538330344f, 0.1985973691f, 0.04756959659f), make_float3(0.04574384897f, 0.9417772198f, 0.01247893122f), make_float3(-0.001210340355f, 0.0176017173f, 0.9836086231f))


/* Math helper functions ----------------------------*/

__CONSTANT__ float SQRT3 = 1.73205080756887729353f;
__CONSTANT__ float PI =  3.14159265358979323846;

typedef struct {
  float3 x, y, z;
} float3x3;

// Helper function to create a float3x3
__DEVICE__ float3x3 make_float3x3(float3 a, float3 b, float3 c) {
  float3x3 d;
  d.x = a, d.y = b, d.z = c;
  return d;
}

// Return identity 3x3 matrix
__DEVICE__ float3x3 identity() {
  return make_float3x3(make_float3(1.0f, 0.0f, 0.0f), make_float3(0.0f, 1.0f, 0.0f), make_float3(0.0f, 0.0f, 1.0f));
}

// Multiply 3x3 matrix m and float3 vector v
__DEVICE__ float3 vdot(float3x3 m, float3 v) {
  return make_float3(m.x.x*v.x + m.x.y*v.y + m.x.z*v.z, m.y.x*v.x + m.y.y*v.y + m.y.z*v.z, m.z.x*v.x + m.z.y*v.y + m.z.z*v.z);
}

// Safe division of float a by float b
__DEVICE__ float sdivf(float a, float b) {
  if (b == 0.0f) return 0.0f;
  else return a/b;
}

// Safe division of float3 a by float b
__DEVICE__ float3 sdivf3f(float3 a, float b) {
  return make_float3(sdivf(a.x, b), sdivf(a.y, b), sdivf(a.z, b));
}

// Safe element-wise division of float3 a by float3 b
__DEVICE__ float3 sdivf3f3(float3 a, float3 b) {
  return make_float3(sdivf(a.x, b.x), sdivf(a.y, b.y), sdivf(a.z, b.z));
}

// Safe power function raising float a to power float b
__DEVICE__ float spowf(float a, float b) {
  if (a <= 0.0f) return a;
  else return _powf(a, b);
}

// Safe power function raising float3 a to power float b
__DEVICE__ float3 spowf3(float3 a, float b) {
  return make_float3(spowf(a.x, b), spowf(a.y, b), spowf(a.z, b));
}

// Return the hypot or vector length of float3 a
__DEVICE__ float hypotf3(float3 a) { return _sqrtf(a.x*a.x + a.y*a.y + a.z*a.z); }

// Return the min of float3 a
__DEVICE__ float fmaxf3(float3 a) { return _fmaxf(a.x, _fmaxf(a.y, a.z)); }

// Return the max of float3 a
__DEVICE__ float fminf3(float3 a) { return _fminf(a.x, _fminf(a.y, a.z)); }

// Clamp float3 a to max value mx
__DEVICE__ float3 clampmaxf3(float3 a, float mx) { return make_float3(_fminf(a.x, mx), _fminf(a.y, mx), _fminf(a.z, mx)); }

// Clamp float3 a to min value mn
__DEVICE__ float3 clampminf3(float3 a, float mn) { return make_float3(_fmaxf(a.x, mn), _fmaxf(a.y, mn), _fmaxf(a.z, mn)); }

// Clamp float3 a to min value mn and max value mx
__DEVICE__ float clampf(float a, float mn, float mx) { return _fminf(_fmaxf(a, mn), mx); }
__DEVICE__ float3 clampf3(float3 a, float mn, float mx) { return make_float3(clampf(a.x, mn, mx), clampf(a.y, mn, mx), clampf(a.z, mn, mx)); }


/* OETF Linearization Transfer Functions ---------------------------------------- */

__DEVICE__ float oetf_davinci_intermediate(float x) {
    return x <= 0.02740668f ? x/10.44426855f : _exp2f(x/0.07329248f - 7.0f) - 0.0075f;
}
__DEVICE__ float oetf_filmlight_tlog(float x) {
  return x < 0.075f ? (x-0.075f)/16.184376489665897f : _expf((x - 0.5520126568606655f)/0.09232902596577353f) - 0.0057048244042473785f;
}
__DEVICE__ float oetf_acescct(float x) {
  return x <= 0.155251141552511f ? (x - 0.0729055341958355f)/10.5402377416545f : _exp2f(x*17.52f - 9.72f);
}
__DEVICE__ float oetf_arri_logc3(float x) {
  return x < 5.367655f*0.010591f + 0.092809f ? (x - 0.092809f)/5.367655f : (_exp10f((x - 0.385537f)/0.247190f) - 0.052272f)/5.555556f;
}
__DEVICE__ float oetf_arri_logc4(float x) {
  return x < -0.7774983977293537f ? x*0.3033266726886969f - 0.7774983977293537f : (_exp2f(14.0f*(x - 0.09286412512218964f)/0.9071358748778103f + 6.0f) - 64.0f)/2231.8263090676883f;
}
__DEVICE__ float oetf_red_log3g10(float x) {
  return x < 0.0f ? (x/15.1927f) - 0.01f : (_exp10f(x/0.224282f) - 1.0f)/155.975327f - 0.01f;
}
__DEVICE__ float oetf_panasonic_vlog(float x) {
  return x < 0.181f ? (x - 0.125f)/5.6f : _exp10f((x - 0.598206f)/0.241514f) - 0.00873f;
}
__DEVICE__ float oetf_sony_slog3(float x) {
  return x < 171.2102946929f/1023.0f ? (x*1023.0f - 95.0f)*0.01125f/(171.2102946929f - 95.0f) : (_exp10f(((x*1023.0f - 420.0f)/261.5f))*(0.18f + 0.01f) - 0.01f);
}
__DEVICE__ float oetf_fujifilm_flog2(float x) {
  return x < 0.100686685370811f ? (x - 0.092864f)/8.799461f : (_exp10f(((x - 0.384316f)/0.245281f))/5.555556f - 0.064829f/5.555556f);
}


__DEVICE__ float3 linearize(float3 rgb, int tf) {
  if (tf==0) { // Linear
    return rgb;
  } else if (tf==1) { // Davinci Intermediate
    rgb.x = oetf_davinci_intermediate(rgb.x);
    rgb.y = oetf_davinci_intermediate(rgb.y);
    rgb.z = oetf_davinci_intermediate(rgb.z);
  } else if (tf==2) { // Filmlight T-Log
    rgb.x = oetf_filmlight_tlog(rgb.x);
    rgb.y = oetf_filmlight_tlog(rgb.y);
    rgb.z = oetf_filmlight_tlog(rgb.z);
  } else if (tf==3) { // ACEScct
    rgb.x = oetf_acescct(rgb.x);
    rgb.y = oetf_acescct(rgb.y);
    rgb.z = oetf_acescct(rgb.z);
  } else if (tf==4) { // Arri LogC3
    rgb.x = oetf_arri_logc3(rgb.x);
    rgb.y = oetf_arri_logc3(rgb.y);
    rgb.z = oetf_arri_logc3(rgb.z);
  } else if (tf==5) { // Arri LogC4
    rgb.x = oetf_arri_logc4(rgb.x);
    rgb.y = oetf_arri_logc4(rgb.y);
    rgb.z = oetf_arri_logc4(rgb.z);
  } else if (tf==6) { // RedLog3G10
    rgb.x = oetf_red_log3g10(rgb.x);
    rgb.y = oetf_red_log3g10(rgb.y);
    rgb.z = oetf_red_log3g10(rgb.z);
  } else if (tf==7) { // Panasonic V-Log
    rgb.x = oetf_panasonic_vlog(rgb.x);
    rgb.y = oetf_panasonic_vlog(rgb.y);
    rgb.z = oetf_panasonic_vlog(rgb.z);
  } else if (tf==8) { // Sony S-Log3
    rgb.x = oetf_sony_slog3(rgb.x);
    rgb.y = oetf_sony_slog3(rgb.y);
    rgb.z = oetf_sony_slog3(rgb.z);
  } else if (tf==9) { // Fuji F-Log2
    rgb.x = oetf_fujifilm_flog2(rgb.x);
    rgb.y = oetf_fujifilm_flog2(rgb.y);
    rgb.z = oetf_fujifilm_flog2(rgb.z);
  }  return rgb;
}



/* EOTF Transfer Functions ---------------------------------------- */

__DEVICE__ float3 eotf_hlg(float3 rgb, int inverse) {
  /* Apply the HLG Forward or Inverse EOTF for 1000 nits.
      ITU-R Rec BT.2100-2 https://www.itu.int/rec/R-REC-BT.2100
      ITU-R Rep BT.2390-8: https://www.itu.int/pub/R-REP-BT.2390
  */

  if (inverse == 1) {
    float Yd = 0.2627f*rgb.x + 0.6780f*rgb.y + 0.0593f*rgb.z;
    rgb = rgb*spowf(Yd, (1.0f - 1.2f)/1.2f);
    rgb.x = rgb.x <= 1.0f/12.0f ? _sqrtf(3.0f*rgb.x) : 0.17883277f*_logf(12.0f*rgb.x - 0.28466892f) + 0.55991073f;
    rgb.y = rgb.y <= 1.0f/12.0f ? _sqrtf(3.0f*rgb.y) : 0.17883277f*_logf(12.0f*rgb.y - 0.28466892f) + 0.55991073f;
    rgb.z = rgb.z <= 1.0f/12.0f ? _sqrtf(3.0f*rgb.z) : 0.17883277f*_logf(12.0f*rgb.z - 0.28466892f) + 0.55991073f;
  } else {
    rgb.x = rgb.x <= 0.5f ? rgb.x*rgb.x/3.0f : (_expf((rgb.x - 0.55991073f)/0.17883277f) + 0.28466892f)/12.0f;
    rgb.y = rgb.y <= 0.5f ? rgb.y*rgb.y/3.0f : (_expf((rgb.y - 0.55991073f)/0.17883277f) + 0.28466892f)/12.0f;
    rgb.z = rgb.z <= 0.5f ? rgb.z*rgb.z/3.0f : (_expf((rgb.z - 0.55991073f)/0.17883277f) + 0.28466892f)/12.0f;
    float Ys = 0.2627f*rgb.x + 0.6780f*rgb.y + 0.0593f*rgb.z;
    rgb = rgb*spowf(Ys, 1.2f - 1.0f);
  }
  return rgb;
}


__DEVICE__ float3 eotf_pq(float3 rgb, int inverse) {
  /* Apply the ST-2084 PQ Forward or Inverse EOTF
      ITU-R Rec BT.2100-2 https://www.itu.int/rec/R-REC-BT.2100
      ITU-R Rep BT.2390-9 https://www.itu.int/pub/R-REP-BT.2390
      Note: in the spec there is a normalization for peak display luminance.
      For this function we assume the input is already normalized such that 1.0 = 10,000 nits
  */

  const float m1 = 2610.0f/16384.0f;
  const float m2 = 2523.0f/32.0f;
  const float c1 = 107.0f/128.0f;
  const float c2 = 2413.0f/128.0f;
  const float c3 = 2392.0f/128.0f;

  if (inverse == 1) {
    rgb = spowf3(rgb, m1);
    rgb = spowf3((c1 + c2*rgb)/(1.0f + c3*rgb), m2);
  } else {
    rgb = spowf3(rgb, 1.0f/m2);
    rgb = spowf3((rgb - c1)/(c2 - c3*rgb), 1.0f/m1);
  }
  return rgb;
}


/* Functions for OpenDRT ---------------------------------------- */

__DEVICE__ float compress_hyperbolic_power(float x, float s, float p) {
  // Simple hyperbolic compression function https://www.desmos.com/calculator/ofwtcmzc3w
  return spowf(x/(x + s), p);
}

__DEVICE__ float compress_toe_quadratic(float x, float toe, int inv) {
  // Quadratic toe compress function https://www.desmos.com/calculator/skk8ahmnws
  if (toe == 0.0f) return x;
  if (inv == 0) {
    return spowf(x, 2.0f)/(x + toe);
  } else {
    return (x + _sqrtf(x*(4.0f*toe + x)))/2.0f;
  }
}

__DEVICE__ float compress_toe_cubic(float x, float m, float w, int inv) {
  // https://www.desmos.com/calculator/ubgteikoke
  if (m==1.0f) return x;
  float x2 = x*x;
  if (inv == 0) {
    return x*(x2 + m*w)/(x2 + w);
  } else {
    float p0 = x2 - 3.0f*m*w;
    float p1 = 2.0f*x2 + 27.0f*w - 9.0f*m*w;
    float p2 = _powf(_sqrtf(x2*p1*p1 - 4*p0*p0*p0)/2.0f + x*p1/2.0f, 1.0f/3.0f);
    return p0/(3.0f*p2) + p2/3.0f + x/3.0f;
  }
}

__DEVICE__ float complement_power(float x, float p) {
  return 1.0f - spowf(1.0f - x, 1.0f/p);
}

__DEVICE__ float sigmoid_cubic(float x, float s) {
  // Simple cubic sigmoid: https://www.desmos.com/calculator/hzgib42en6
  if (x < 0.0f || x > 1.0f) return 1.0f;
  return 1.0f + s*(1.0f - 3.0f*x*x + 2.0f*x*x*x);
}

__DEVICE__ float contrast_high(float x, float p, float pv, float pv_lx, int inv) {
  // High exposure adjustment with linear extension
  // https://www.desmos.com/calculator/etjgwyrgad
  const float x0 = 0.18f*_powf(2.0f, pv);
  if (x < x0 || p == 1.0f) return x;

  const float o = x0 - x0/p;
  const float s0 = _powf(x0, 1.0f - p)/p;
  const float x1 = x0*_powf(2.0f, pv_lx);
  const float k1 = p*s0*_powf(x1, p)/x1;
  const float y1 = s0*_powf(x1, p) + o;
  if (inv==1)
    return x > y1 ? (x - y1)/k1 + x1 : _powf((x - o)/s0, 1.0f/p);
  else
    return x > x1 ? k1*(x - x1) + y1 : s0*_powf(x, p) + o;
}

__DEVICE__ float softplus_constraint(float x, float s, float x0, float y0) {
  // Softplus with (x0, y0) intersection constraint
  // https://www.desmos.com/calculator/doipi4u0ce
  if (x > 10.0f*s + y0 || s < 1e-3f) return x;
  float m = 1.0f;
  if (_fabs(y0) > 1e-6f) m = _expf(y0/s);
  m -= _expf(x0/s);
  return s*_logf(_fmaxf(0.0f, m + _expf(x/s)));
}

__DEVICE__ float softplus(float x, float s) {
  // Softplus unconstrained
  // https://www.desmos.com/calculator/mr9rmujsmn
  if (x > 10.0f*s || s < 1e-3f) return x;
  return s*_logf(_fmaxf(0.0f, 1.0f + _expf(x/s)));
}

__DEVICE__ float gauss_window(float x, float w) {
  // Simple gaussian window https://www.desmos.com/calculator/vhr9hstlyk
  x /= w;
  return _expf(-x*x);
}


__DEVICE__ float hue_offset(float h, float o) {
  // Offset hue maintaining 0-2*pi range with modulo
  return _fmod(h - o + PI, 2.0*PI) - PI;
}



__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B)
{
  float3 rgb = make_float3(p_R, p_G, p_B);

  /*****************************************************
    Parameter Setup
    --------------------------------------------------*/

  // Init look preset variables
  int tn_hcon_enable, tn_lcon_enable, ptl_enable, ptm_enable, brl_enable, hs_rgb_enable, hs_cmy_enable, hc_enable, cwp, display_gamut, eotf;
  float tn_Lg, tn_con, tn_sh, tn_toe, tn_off, tn_hcon, tn_hcon_pv, tn_hcon_st, tn_lcon, tn_lcon_w, tn_lcon_pc, cwp_rng, rs_sa, rs_rw, rs_bw, pt_r, pt_g, pt_b, pt_rng_low, pt_rng_high, ptm_low, ptm_low_st, ptm_high, ptm_high_st, brl_r, brl_g, brl_b, brl_c, brl_m, brl_y, brl_rng, hs_r, hs_g, hs_b, hs_rgb_rng, hs_c, hs_m, hs_y, hc_r;

  #ifdef INIT_PARAMS  // Set all parameters to the user-controllable ones instead of presets if INIT_PARAMS defined by user.

  tn_Lg=_tn_Lg, tn_con=_tn_con, tn_sh=_tn_sh, tn_toe=_tn_toe, tn_off=_tn_off, tn_hcon_enable=_tn_hcon_enable, tn_hcon=_tn_hcon, tn_hcon_pv=_tn_hcon_pv, tn_hcon_st=_tn_hcon_st, tn_lcon_enable=_tn_lcon_enable, tn_lcon=_tn_lcon, tn_lcon_w=_tn_lcon_w, tn_lcon_pc=_tn_lcon_pc, cwp=_cwp, cwp_rng=_cwp_rng, rs_sa=_rs_sa, rs_rw=_rs_rw, rs_bw=_rs_bw, pt_r=_pt_r, pt_g=_pt_g, pt_b=_pt_b, pt_rng_low=_pt_rng_low, pt_rng_high=_pt_rng_high, ptl_enable=_ptl_enable, ptm_enable=_ptm_enable, ptm_low=_ptm_low, ptm_low_st=_ptm_low_st, ptm_high=_ptm_high, ptm_high_st=_ptm_high_st, brl_enable=_brl_enable, brl_r=_brl_r, brl_g=_brl_g, brl_b=_brl_b, brl_c=_brl_c, brl_m=_brl_m, brl_y=_brl_y, brl_rng=_brl_rng, hs_rgb_enable=_hs_rgb_enable, hs_r=_hs_r, hs_g=_hs_g, hs_b=_hs_b, hs_rgb_rng=_hs_rgb_rng, hs_cmy_enable=_hs_cmy_enable, hs_c=_hs_c, hs_m=_hs_m, hs_y=_hs_y, hc_enable=_hc_enable, hc_r=_hc_r, display_gamut=_display_gamut, eotf=_eotf;

  #else // Otherwise, drive everything based on the preset combo box parameters.

  /*----------- LOOK PRESETS -----------------*/
  // Look presets to go after
  if (look_preset==0) { // Default
    tn_Lg = 11.1f, tn_con = 1.4f, tn_sh = 0.5f, tn_toe = 0.003f, tn_off = 0.005f, tn_hcon_enable = 0, tn_hcon = 0.0f, tn_hcon_pv = 1.0f, tn_hcon_st = 4.0f, tn_lcon_enable = 1, tn_lcon = 1.0f, tn_lcon_w = 0.5f, tn_lcon_pc = 1.0f, cwp = 0, cwp_rng = 0.5f, rs_sa = 0.35f, rs_rw = 0.25f, rs_bw = 0.55f, pt_r = 0.5f, pt_g = 2.0f, pt_b = 2.0f, pt_rng_low = 0.2f, pt_rng_high = 0.8f, ptl_enable = 1, ptm_enable = 1, ptm_low = 0.2f, ptm_low_st = 0.5f, ptm_high = -0.8f, ptm_high_st = 0.3f, brl_enable = 1, brl_r = -0.5f, brl_g = -0.4f, brl_b = -0.2f, brl_c = 0.0f, brl_m = 0.0f, brl_y = 0.0f, brl_rng = 0.66f, hs_rgb_enable = 1, hs_r = 0.35f, hs_g = 0.25f, hs_b = 0.5f, hs_rgb_rng = 0.6f, hs_cmy_enable = 1, hs_c = 0.2f, hs_m = 0.2f, hs_y = 0.2f, hc_enable = 1, hc_r = 0.6f;
  }
  else if (look_preset==1) { // Colorful
    tn_Lg = 11.1f, tn_con = 1.3f, tn_sh = 0.5f, tn_toe = 0.005f, tn_off = 0.005f, tn_hcon_enable = 0, tn_hcon = 0.0f, tn_hcon_pv = 1.0f, tn_hcon_st = 4.0f, tn_lcon_enable = 1, tn_lcon = 0.75f, tn_lcon_w = 1.0f, tn_lcon_pc = 1.0f, cwp = 0, cwp_rng = 0.5f, rs_sa = 0.35f, rs_rw = 0.15f, rs_bw = 0.55f, pt_r = 0.5f, pt_g = 0.8f, pt_b = 0.5f, pt_rng_low = 0.25f, pt_rng_high = 0.5f, ptl_enable = 1, ptm_enable = 1, ptm_low = 0.5f, ptm_low_st = 0.5f, ptm_high = -0.8f, ptm_high_st = 0.3f, brl_enable = 1, brl_r = -0.55f, brl_g = -0.5f, brl_b = 0.0f, brl_c = 0.0f, brl_m = 0.0f, brl_y = 0.1f, brl_rng = 0.5f, hs_rgb_enable = 1, hs_r = 0.4f, hs_g = 0.6f, hs_b = 0.5f, hs_rgb_rng = 0.6f, hs_cmy_enable = 1, hs_c = 0.2f, hs_m = 0.1f, hs_y = 0.2f, hc_enable = 1, hc_r = 0.8f;
  }
  else if (look_preset==2) { // Umbra
    tn_Lg = 6.0f, tn_con = 1.8f, tn_sh = 0.5f, tn_toe = 0.001f, tn_off = 0.015f, tn_hcon_enable = 0, tn_hcon = 0.0f, tn_hcon_pv = 1.0f, tn_hcon_st = 4.0f, tn_lcon_enable = 1, tn_lcon = 1.0f, tn_lcon_w = 1.0f, tn_lcon_pc = 1.0f, cwp = 3, cwp_rng = 0.8f, rs_sa = 0.45f, rs_rw = 0.1f, rs_bw = 0.35f, pt_r = 0.1f, pt_g = 0.4f, pt_b = 2.5f, pt_rng_low = 0.2f, pt_rng_high = 0.8f, ptl_enable = 1, ptm_enable = 1, ptm_low = 0.4f, ptm_low_st = 0.5f, ptm_high = -0.8f, ptm_high_st = 0.3f, brl_enable = 1, brl_r = -0.7f, brl_g = -0.6f, brl_b = -0.2f, brl_c = 0.0f, brl_m = -0.25f, brl_y = 0.1f, brl_rng = 0.9f, hs_rgb_enable = 1, hs_r = 0.4f, hs_g = 0.8f, hs_b = 0.4f, hs_rgb_rng = 1.0f, hs_cmy_enable = 1, hs_c = 1.0f, hs_m = 0.6f, hs_y = 1.0f, hc_enable = 1, hc_r = 0.8f;
  }
  else if (look_preset==3) { // Base
    tn_Lg = 11.1f, tn_con = 1.4f, tn_sh = 0.5f, tn_toe = 0.003f, tn_off = 0.0f, tn_hcon_enable = 0, tn_hcon = 0.0f, tn_hcon_pv = 1.0f, tn_hcon_st = 4.0f, tn_lcon_enable = 0, tn_lcon = 0.0f, tn_lcon_w = 0.5f, tn_lcon_pc = 1.0f, cwp = 0, cwp_rng = 0.5f, rs_sa = 0.35f, rs_rw = 0.25f, rs_bw = 0.5f, pt_r = 1.0f, pt_g = 2.0f, pt_b = 2.5f, pt_rng_low = 0.25f, pt_rng_high = 0.25f, ptl_enable = 1, ptm_enable = 0, ptm_low = 0.0f, ptm_low_st = 0.5f, ptm_high = 0.0f, ptm_high_st = 0.3f, brl_enable = 0, brl_r = 0.0f, brl_g = 0.0f, brl_b = 0.0f, brl_c = 0.0f, brl_m = 0.0f, brl_y = 0.0f, brl_rng = 0.5f, hs_rgb_enable = 0, hs_r = 0.0f, hs_g = 0.0f, hs_b = 0.0f, hs_rgb_rng = 0.5f, hs_cmy_enable = 0, hs_c = 0.0f, hs_m = 0.0f, hs_y = 0.0f, hc_enable = 0, hc_r = 0.0f;
  }

  /*----------- TONESCALE PRESETS -----------------*/
  if (tonescale_preset==0) { // Do nothing and use tonescale settings from the look preset
  }
  if (tonescale_preset==1) { // High-Contrast
    tn_Lg = 11.1f, tn_con = 1.4f, tn_sh = 0.5f, tn_toe = 0.003f, tn_off = 0.005f, tn_hcon_enable = 0, tn_hcon = 0.0f, tn_hcon_pv = 1.0f, tn_hcon_st = 4.0f, tn_lcon_enable = 1, tn_lcon = 1.0f, tn_lcon_w = 0.5f, tn_lcon_pc = 1.0f;
  }
  else if (tonescale_preset==2) { // Low-Contrast
    tn_Lg = 11.1f, tn_con = 1.4f, tn_sh = 0.5f, tn_toe = 0.003f, tn_off = 0.005f, tn_hcon_enable = 0, tn_hcon = 0.0f, tn_hcon_pv = 1.0f, tn_hcon_st = 4.0f, tn_lcon_enable = 0, tn_lcon = 0.0f, tn_lcon_w = 0.5f, tn_lcon_pc = 1.0f;
  }
  else if (tonescale_preset==3) { // ACES-1.x
    tn_Lg = 10.0f, tn_con = 1.0f, tn_sh = 0.245f, tn_toe = 0.02f, tn_off = 0.0f, tn_hcon_enable = 1, tn_hcon = 0.55f, tn_hcon_pv = 0.0f, tn_hcon_st = 2.0f, tn_lcon_enable = 1, tn_lcon = 1.13f, tn_lcon_w = 1.0f, tn_lcon_pc = 1.0f;
  }
  else if (tonescale_preset==4) { // ACES-2.0
    tn_Lg = 10.0f, tn_con = 1.15f, tn_sh = 0.5f, tn_toe = 0.04f, tn_off = 0.0f, tn_hcon_enable = 0, tn_hcon = 1.0f, tn_hcon_pv = 1.0f, tn_hcon_st = 1.0f, tn_lcon_enable = 0, tn_lcon = 1.0f, tn_lcon_w = 0.6f, tn_lcon_pc = 1.0f;
  }
  else if (tonescale_preset==5) { // Marvelous Tonescape
    tn_Lg = 6.0f, tn_con = 1.5f, tn_sh = 0.5f, tn_toe = 0.003f, tn_off = 0.01f, tn_hcon_enable = 1, tn_hcon = 0.25f, tn_hcon_pv = 0.0f, tn_hcon_st = 4.0f, tn_lcon_enable = 1, tn_lcon = 1.0f, tn_lcon_w = 1.0f, tn_lcon_pc = 1.0f;
  }
  else if (tonescale_preset==6) { // Arriba Tonecall
    tn_Lg = 11.1f, tn_con = 1.05f, tn_sh = 0.5f, tn_toe = 0.1f, tn_off = 0.015f, tn_hcon_enable = 0, tn_hcon = 0.0f, tn_hcon_pv = 0.0f, tn_hcon_st = 2.0f, tn_lcon_enable = 1, tn_lcon = 2.0f, tn_lcon_w = 0.2f, tn_lcon_pc = 1.0f;
  }
  else if (tonescale_preset==7) { // DaGrinchi Tonegroan
    tn_Lg = 10.42f, tn_con = 1.2f, tn_sh = 0.5f, tn_toe = 0.02f, tn_off = 0.0f, tn_hcon_enable = 0, tn_hcon = 0.0f, tn_hcon_pv = 1.0f, tn_hcon_st = 1.0f, tn_lcon_enable = 0, tn_lcon = 0.0f, tn_lcon_w = 0.6f, tn_lcon_pc = 1.0f;
  }
  else if (tonescale_preset==8) { // Aery Tonescale
    tn_Lg = 11.1f, tn_con = 1.15f, tn_sh = 0.5f, tn_toe = 0.04f, tn_off = 0.006f, tn_hcon_enable = 0, tn_hcon = 0.0f, tn_hcon_pv = 0.0f, tn_hcon_st = 0.5f, tn_lcon_enable = 1, tn_lcon = 0.5f, tn_lcon_w = 2.0f, tn_lcon_pc = 0.5f;
  }
  else if (tonescale_preset==9) { // Umbra Tonescale
    tn_Lg = 6.0f, tn_con = 1.8f, tn_sh = 0.5f, tn_toe = 0.001f, tn_off = 0.015f, tn_hcon_enable = 0, tn_hcon = 0.0f, tn_hcon_pv = 1.0f, tn_hcon_st = 4.0f, tn_lcon_enable = 1, tn_lcon = 1.0f, tn_lcon_w = 1.0f, tn_lcon_pc = 1.0f;
  }
  
  /*----------- CREATIVE WHITE PRESETS -----------------*/
  // Use user creative whitepoint settings if custom whitepoint specified, otherwise use the one from the look preset
  if (_cwp!=4) cwp_rng = _cwp_rng; 
  if (_cwp==0) cwp = 0; // D65
  else if (_cwp==1) cwp = 1; // D60
  else if (_cwp==2) cwp = 2; // D55
  else if (_cwp==3) cwp = 3; // D50


  /*----------- DISPLAY ENCODING PRESETS -----------------*/
  if (display_encoding_preset==0) { // Rec.1886
    display_gamut = 0;
    eotf = 2;
  }
  else if (display_encoding_preset==1) { // sRGB Display
    display_gamut = 0;
    eotf = 1;
  }
  else if (display_encoding_preset==2) { // Display P3
    display_gamut = 1;
    eotf = 1;
  }
  else if (display_encoding_preset==3) { // Rec.2100 PQ
    display_gamut = 2;
    eotf = 4;
  }
  else if (display_encoding_preset==4) { // Rec.2100 HLG
    display_gamut = 2;
    eotf = 5;
  }
  else if (display_encoding_preset==5) { // Dolby PQ
    display_gamut = 1;
    eotf = 4;
  }
  #endif

  float3x3 in_to_xyz;
  if (in_gamut==0) in_to_xyz = identity();
  else if (in_gamut==1) in_to_xyz = matrix_ap0_to_xyz;
  else if (in_gamut==2) in_to_xyz = matrix_ap1_to_xyz;
  else if (in_gamut==3) in_to_xyz = matrix_p3d65_to_xyz;
  else if (in_gamut==4) in_to_xyz = matrix_rec2020_to_xyz;
  else if (in_gamut==5) in_to_xyz = matrix_rec709_to_xyz;
  else if (in_gamut==6) in_to_xyz = matrix_arriwg3_to_xyz;
  else if (in_gamut==7) in_to_xyz = matrix_arriwg4_to_xyz;
  else if (in_gamut==8) in_to_xyz = matrix_redwg_to_xyz;
  else if (in_gamut==9) in_to_xyz = matrix_sonysgamut3_to_xyz;
  else if (in_gamut==10) in_to_xyz = matrix_sonysgamut3cine_to_xyz;
  else if (in_gamut==11) in_to_xyz = matrix_vgamut_to_xyz;
  else if (in_gamut==12) in_to_xyz = matrix_bmdwg_to_xyz;
  else if (in_gamut==13) in_to_xyz = matrix_egamut_to_xyz;
  else if (in_gamut==14) in_to_xyz = matrix_egamut2_to_xyz;
  else if (in_gamut==15) in_to_xyz = matrix_davinciwg_to_xyz;

  float crv_val = 0.0f;

  // x-position based input value for tonescale overlay
  if (crv_enable == 1) crv_val = oetf_filmlight_tlog(float(p_X) / float(p_Width));

  // Linearize if a non-linear input oetf / transfer function is selected
  rgb = linearize(rgb, in_oetf);


  /***************************************************
    Tonescale Constraint Calculations
    https://www.desmos.com/calculator/1c4fhzy3bw

    These could be pre-calculated but there is no way to do this in DCTL.
    Anything that is const should be precalculated and not run per-pixel
    --------------------------------------------------*/
  const float ts_x1 = _powf(2.0f, 6.0f*tn_sh + 4.0f);
  const float ts_y1 = tn_Lp/100.0f;
  const float ts_x0 = 0.18f + tn_off;
  const float ts_y0 = tn_Lg/100.0f*(1.0f + tn_gb*_log2f(ts_y1));
  const float ts_s0 = compress_toe_quadratic(ts_y0, tn_toe, 1);
  const float ts_s10 = ts_x0*(_powf(ts_s0, -1.0f/tn_con) - 1.0f);
  const float ts_m1 = ts_y1/_powf(ts_x1/(ts_x1 + ts_s10), tn_con);
  const float ts_m2 = compress_toe_quadratic(ts_m1, tn_toe, 1);
  const float ts_s = ts_x0*(_powf(ts_s0/ts_m2, -1.0f/tn_con) - 1.0f);
  const float ts_dsc = eotf==4 ? 0.01 : eotf==5 ? 0.1 : 100.0f/tn_Lp;

  // Lerp from pt_cmp at 100 nits to pt_cmp_hdr at 1000 nits
  const float pt_cmp_Lf = pt_hdr*_fminf(1.0f, (tn_Lp - 100.0f)/900.0f);
  // Approximate scene-linear scale at Lp=100 nits
  const float s_Lp100 = ts_x0*(_powf((tn_Lg/100.0f), -1.0f/tn_con) - 1.0f);
  const float ts_s1 = ts_s*pt_cmp_Lf + s_Lp100*(1.0f - pt_cmp_Lf);


  // Convert from input gamut into P3-D65
  rgb = vdot(in_to_xyz, rgb);
  rgb = vdot(matrix_xyz_to_p3d65, rgb);


  // Rendering Space: "Desaturate" to control scale of the color volume in the rgb ratios.
  // Controlled by rs_sa (saturation) and red and blue weights (rs_rw and rs_bw)
  float3 rs_w = make_float3(rs_rw, 1.0f - rs_rw - rs_bw, rs_bw);
  float sat_L = rgb.x*rs_w.x + rgb.y*rs_w.y + rgb.z*rs_w.z;
  rgb = sat_L*rs_sa + rgb*(1.0f - rs_sa);


  // Offset
  rgb += tn_off;
  if (crv_enable == 1) crv_val += tn_off;


  /***************************************************
    Contrast Low Module
  --------------------------------------------------*/
  if (tn_lcon_enable) {
    float mcon_m = _powf(2.0f, -tn_lcon);
    float mcon_w = tn_lcon_w/4.0f;
    mcon_w *= mcon_w;

    // Normalize for ts_x0 intersection constraint: https://www.desmos.com/calculator/blyvi8t2b2
    const float mcon_cnst_sc = compress_toe_cubic(ts_x0, mcon_m, mcon_w, 1)/ts_x0;
    rgb *= mcon_cnst_sc;

    // Scale for ratio-preserving midtone contrast
    float mcon_nm = hypotf3(clampminf3(rgb, 0.0f))/SQRT3;
    float mcon_sc = (mcon_nm*mcon_nm + mcon_m*mcon_w)/(mcon_nm*mcon_nm + mcon_w);

    if (tn_lcon_pc > 0.0f) {
      // Mix between ratio-preserving and per-channel by blending based on distance from achromatic

      // Apply per-channel midtone contrast
      float3 mcon_rgb = rgb;
      mcon_rgb.x = compress_toe_cubic(rgb.x, mcon_m, mcon_w, 0);
      mcon_rgb.y = compress_toe_cubic(rgb.y, mcon_m, mcon_w, 0);
      mcon_rgb.z = compress_toe_cubic(rgb.z, mcon_m, mcon_w, 0);

      // Always use some amount of ratio-preserving method towards gamut boundary
      float mcon_mx = fmaxf3(rgb);
      float mcon_mn = fminf3(rgb);
      float mcon_ch = clampf(1.0f - sdivf(mcon_mn, mcon_mx), 0.0, 1.0);
      mcon_ch = _powf(mcon_ch, 4.0f*tn_lcon_pc);
      rgb = mcon_sc*rgb*mcon_ch + mcon_rgb*(1.0f - mcon_ch);
    }
    else { // Just use ratio-preserving
      rgb = mcon_sc*rgb;
    }
    
    if (crv_enable == 1) {
      crv_val *= mcon_cnst_sc;
      crv_val = crv_val*(crv_val*crv_val + mcon_m*mcon_w)/(crv_val*crv_val + mcon_w);
    }
  }


  // Tonescale Norm
  float tsn = hypotf3(clampminf3(rgb, 0.0f))/SQRT3;
  // Purity Compression Norm
  float ts_pt = _sqrtf(_fmaxf(0.0f, rgb.x*rgb.x*pt_r + rgb.y*rgb.y*pt_g + rgb.z*rgb.z*pt_b));

  // RGB Ratios
  rgb = sdivf3f(clampminf3(rgb, -2.0f), tsn);



  // Apply High Contrast
  if (tn_hcon_enable) {
    float hcon_p = _powf(2.0f, tn_hcon);
    tsn = contrast_high(tsn, hcon_p, tn_hcon_pv, tn_hcon_st, 0);
    ts_pt = contrast_high(ts_pt, hcon_p, tn_hcon_pv, tn_hcon_st, 0);
    
    if (crv_enable == 1) crv_val = contrast_high(crv_val, hcon_p, tn_hcon_pv, tn_hcon_st, 0);
  }

  // Apply tonescale
  tsn = compress_hyperbolic_power(tsn, ts_s, tn_con);
  ts_pt = compress_hyperbolic_power(ts_pt, ts_s1, tn_con);
  
  if (crv_enable == 1) crv_val = compress_hyperbolic_power(crv_val, ts_s, tn_con);


  // Simple Cyan-Yellow / Green-Magenta opponent space for calculating smooth achromatic distance and hue angles
  float opp_cy = rgb.x - rgb.z;
  float opp_gm = rgb.y - (rgb.x + rgb.z)/2.0f;
  float ach_d = _sqrtf(_fmaxf(0.0f, opp_cy*opp_cy + opp_gm*opp_gm))/SQRT3;

  // Smooth ach_d, normalized so 1.0 doesn't change https://www.desmos.com/calculator/ozjg09hzef
  ach_d = (1.25f)*compress_toe_quadratic(ach_d, 0.25f, 0);

  // Hue angle, rotated so that red = 0.0
  float hue = _fmod(_atan2f(opp_cy, opp_gm) + PI + 1.10714931f, 2.0f*PI);

  // RGB Hue Angles
  // Wider than CMY by default. R towards M, G towards Y, B towards C
  float3 ha_rgb = make_float3(
    gauss_window(hue_offset(hue, 0.1f), 0.9f),
    gauss_window(hue_offset(hue, 4.3f), 0.9f),
    gauss_window(hue_offset(hue, 2.3f), 0.9f));

  // CMY Hue Angles
  // Exact alignment to Cyan/Magenta/Yellow secondaries would be PI, PI/3 and -PI/3, but
  // we customize these a bit for creative purposes: M towards B, Y towards G, C towards G
  float3 ha_cmy = make_float3(
    gauss_window(hue_offset(hue, 3.3f), 0.6f),
    gauss_window(hue_offset(hue, 1.3f), 0.6f),
    gauss_window(hue_offset(hue, -1.2), 0.6f));


  // Purity Compression Range: https://www.desmos.com/calculator/8ynarg1uxk
  float ts_pt_cmp = 1.0f - _powf(ts_pt, 1.0f/pt_rng_low);

  float pt_rng_high_f = _fminf(1.0f, ach_d/1.2f);
  pt_rng_high_f *= pt_rng_high_f;
  pt_rng_high_f = pt_rng_high < 1.0f ? 1.0f - pt_rng_high_f : pt_rng_high_f;
  ts_pt_cmp = _powf(ts_pt_cmp, pt_rng_high)*(1.0f - pt_rng_high_f) + ts_pt_cmp*pt_rng_high_f;


  /***************************************************
    Brilliance
  --------------------------------------------------*/
  float brl_f = 1.0f;
  if (brl_enable) {
    brl_f = -brl_r*ha_rgb.x - brl_g*ha_rgb.y - brl_b*ha_rgb.z - brl_c*ha_cmy.x - brl_m*ha_cmy.y - brl_y*ha_cmy.z;
    brl_f = (1.0f - ach_d)*brl_f + 1.0f - brl_f;
    brl_f = softplus(brl_f, 0.25f); // Protect against over-darkening
    
    // Limit Brilliance adjustment by tonescale
    float brl_ts = brl_f > 1.0f ? 1.0f - ts_pt : ts_pt; // Limit by inverse tonescale if positive Brilliance adjustment
    float brl_lim = spowf(brl_ts, 1.0f - brl_rng);
    brl_f = brl_f*brl_lim + 1.0f - brl_lim;
    brl_f = _fmaxf(0.0f, _fminf(2.0f, brl_f)); // protect for shadow grain
  }



  /***************************************************
    Mid-Range Purity
      This boosts mid-range purity on the low end
      and reduces mid-range purity on the high end
  --------------------------------------------------*/
  float ptm_sc = 1.0f;
  if (ptm_enable) {
    // Mid Purity Low
    float ptm_ach_d = complement_power(ach_d, ptm_low_st);
    ptm_sc = sigmoid_cubic(ptm_ach_d, ptm_low*(1.0f - ts_pt));

    // Mid Purity High
    ptm_ach_d = complement_power(ach_d, ptm_high_st)*(1.0f - ts_pt) + ach_d*ach_d*ts_pt;
    ptm_sc *= sigmoid_cubic(ptm_ach_d, ptm_high*ts_pt);
    ptm_sc = _fmaxf(0.0f, ptm_sc); // Ensure no negative scale
  }


  // Premult hue angles for Hue Contrast and Hue Shift
  ha_rgb *= ach_d;
  ha_cmy *= (1.5f)*compress_toe_quadratic(ach_d, 0.5f, 0); // Stronger smoothing for CMY hue shift


  /***************************************************
    Hue Contrast R
  --------------------------------------------------*/
  if (hc_enable) {
    float hc_ts = 1.0f - ts_pt;
    // Limit high purity on bottom end and low purity on top end by ach_d.
    // This helps reduce artifacts and over-saturation.
    float hc_c = (1.0f - ach_d)*hc_ts + ach_d*(1.0f - hc_ts);
    hc_c *= ha_rgb.x;
    hc_ts *= hc_ts;
    // Bias contrast based on tonescale using Lift/Mult: https://www.desmos.com/calculator/gzbgov62hl
    float hc_f = hc_r*(hc_c - 2.0f*hc_c*hc_ts) + 1.0f;
    rgb = make_float3(rgb.x, rgb.y*hc_f, rgb.z*hc_f);
  }



  /***************************************************
  Hue Shift
  --------------------------------------------------*/

  // Hue Shift RGB by purity compress tonescale, shifting more as intensity increases
  if (hs_rgb_enable) {
    float3 hs_rgb = ha_rgb*_powf(ts_pt, 1.0f/hs_rgb_rng);
    float3 hsf = make_float3(hs_rgb.x*hs_r, hs_rgb.y*-hs_g, hs_rgb.z*-hs_b);
    hsf = make_float3(hsf.z - hsf.y, hsf.x - hsf.z, hsf.y - hsf.x);
    rgb += hsf;
  }

  // Hue Shift CMY by tonescale, shifting less as intensity increases
  if (hs_cmy_enable) {
    float3 hs_cmy = ha_cmy*(1.0f - ts_pt);
    float3 hsf = make_float3(hs_cmy.x*-hs_c, hs_cmy.y*hs_m, hs_cmy.z*hs_y);
    hsf = make_float3(hsf.z - hsf.y, hsf.x - hsf.z, hsf.y - hsf.x);
    rgb += hsf;
  }

  // Apply brilliance
  rgb *= brl_f;

  // Apply purity compression and mid purity
  ts_pt_cmp *= ptm_sc;
  rgb = rgb*ts_pt_cmp + 1.0f - ts_pt_cmp;

  // Inverse Rendering Space
  sat_L = rgb.x*rs_w.x + rgb.y*rs_w.y + rgb.z*rs_w.z;
  rgb = (sat_L*rs_sa - rgb)/(rs_sa - 1.0f);

  // Convert to final display gamut
  float3 cwp_rgb = rgb;
  if (display_gamut==0) {
    if (cwp==1) cwp_rgb = vdot(matrix_p3_to_rec709_d60, rgb);
    if (cwp==2) cwp_rgb = vdot(matrix_p3_to_rec709_d55, rgb);
    if (cwp==3) cwp_rgb = vdot(matrix_p3_to_rec709_d50, rgb);
    rgb = vdot(matrix_p3_to_rec709_d65, rgb);
    if (cwp==0) cwp_rgb = rgb;
  }
  else if (display_gamut>=1) {
    if (cwp==1) cwp_rgb = vdot(matrix_p3_to_p3_d60, rgb);
    if (cwp==2) cwp_rgb = vdot(matrix_p3_to_p3_d55, rgb);
    if (cwp==3) cwp_rgb = vdot(matrix_p3_to_p3_d50, rgb);
  }

  // Mix between Creative Whitepoint and D65 by tsn
  float cwp_f = _powf(tsn, 1.0f - cwp_rng);
  rgb = cwp_rgb*cwp_f + rgb*(1.0f - cwp_f);

  // Tonescale overlay RGB
  float3 crv_rgb = make_float3(crv_val, crv_val, crv_val);
  float3 crv_rgb_cwp = crv_rgb;
  if (crv_enable == 1) {
    if (display_gamut==0) {
      if (cwp==1) crv_rgb_cwp = vdot(matrix_p3_to_rec709_d60, crv_rgb);
      if (cwp==2) crv_rgb_cwp = vdot(matrix_p3_to_rec709_d55, crv_rgb);
      if (cwp==3) crv_rgb_cwp = vdot(matrix_p3_to_rec709_d50, crv_rgb);
      crv_rgb = vdot(matrix_p3_to_rec709_d65, crv_rgb);
      if (cwp==0) crv_rgb_cwp = crv_rgb;
    }
    else if (display_gamut>=1) {
      if (cwp==1) crv_rgb_cwp = vdot(matrix_p3_to_p3_d60, crv_rgb);
      if (cwp==2) crv_rgb_cwp = vdot(matrix_p3_to_p3_d55, crv_rgb);
      if (cwp==3) crv_rgb_cwp = vdot(matrix_p3_to_p3_d50, crv_rgb);
    }

    float crv_rgb_cwp_f = _powf(crv_val, 1.0f - cwp_rng);
    crv_rgb = crv_rgb_cwp*crv_rgb_cwp_f + crv_rgb*(1.0f - crv_rgb_cwp_f);
  }


  // Purity Compress Low
  if (ptl_enable) {
    float sum0 = softplus_constraint(rgb.x, 0.2f, -100.0f, -0.3f) + rgb.y + softplus_constraint(rgb.z, 0.2f, -100.0f, -0.3f);
    rgb.x = softplus(rgb.x, 0.06f);
    rgb.y = softplus(rgb.y, 0.06f);
    rgb.z = softplus(rgb.z, 0.04f);

    float ptl_norm = _fminf(1.0f, sdivf(sum0, rgb.x + rgb.y + rgb.z));
    rgb *= ptl_norm;
  }

  // Final tonescale adjustments
  tsn *= ts_m2; // scale for inverse toe
  tsn = compress_toe_quadratic(tsn, tn_toe, 0);
  tsn *= ts_dsc; // scale for display encoding

  if (crv_enable == 1) {
    crv_rgb *= ts_m2;
    crv_rgb.x = compress_toe_quadratic(crv_rgb.x, tn_toe, 0);
    crv_rgb.y = compress_toe_quadratic(crv_rgb.y, tn_toe, 0);
    crv_rgb.z = compress_toe_quadratic(crv_rgb.z, tn_toe, 0);
    crv_rgb *= ts_dsc;
    // scale to 1.0 = 1000 nits for st2084 PQ
    if (eotf == 4) crv_rgb *= 10.0f;
  }

  // Return from RGB ratios
  rgb *= tsn;

  // Clamp
  if (_clamp) rgb = clampf3(rgb, 0.0f, 1.0f);

  // Rec.2020 (P3 Limited)
  if (display_gamut==2) {
    rgb = clampminf3(rgb, 0.0f);
    rgb = vdot(matrix_p3_to_rec2020, rgb);
  }


  // Apply inverse Display EOTF
  float eotf_p = 2.0f + eotf * 0.2f;
  if ((eotf > 0) && (eotf < 4)) rgb = spowf3(rgb, 1.0f/eotf_p);
  else if (eotf == 4) rgb = eotf_pq(rgb, 1);
  else if (eotf == 5) rgb = eotf_hlg(rgb, 1);

  if (crv_enable == 1) {
    if ((eotf > 0) && (eotf < 4)) crv_rgb = spowf3(crv_rgb, 1.0f/eotf_p);
    else if (eotf == 4) crv_rgb = eotf_pq(crv_rgb, 1);
    else if (eotf == 5) crv_rgb = eotf_hlg(crv_rgb, 1);
  }

  if (crv_enable == 1) {
    float3 crv_rgb_dst = make_float3(
      float(p_Height-p_Y) - crv_rgb.x*float(p_Height), 
      float(p_Height-p_Y) - crv_rgb.y*float(p_Height), 
      float(p_Height-p_Y) - crv_rgb.z*float(p_Height));
    float crv_w0 = 0.5f; // width of tonescale overlay
    crv_rgb_dst.x = _expf(-crv_rgb_dst.x*crv_rgb_dst.x*crv_w0);
    crv_rgb_dst.y = _expf(-crv_rgb_dst.y*crv_rgb_dst.y*crv_w0);
    crv_rgb_dst.z = _expf(-crv_rgb_dst.z*crv_rgb_dst.z*crv_w0);
    float crv_lm = eotf < 4 ? 1.0f : 0.5f; // reduced luminance in hdr
    crv_rgb_dst = clampf3(crv_rgb_dst, 0.0f, 1.0f);
    rgb = rgb * (1.0f - crv_rgb_dst) + crv_lm*crv_rgb_dst*crv_rgb_dst;
  }

  return rgb;
}